#!/usr/bin/python3
# _*_ coding: utf-8 _*_

"""
This simple script displays i3 or Sway key bindings found in the ~/.config/i3/config or ~/.config/sway/config file
in a GTK+ scrolling window. Save anywhere, make executable, run w/o arguments for i3, or `cheatsheet sway` for Sway.

Author: Piotr Miller
e-mail: nwg.piotr@gmail.com
Website: https://github.com/nwg-piotr/swayinfo
License: GPL-3.0-or-later

Depends on: python (python3) python-gobject
"""

import os
import gi
import sys
gi.require_version('Gtk', '3.0')
from gi.repository import Gtk, Gdk, Pango

# simple map from config file to list of keywords
configs = {
    'sway': (os.path.join(os.getenv('HOME'), '.config/sway/config'), ['bindsym --locked', 'bindsym', 'bindcode'], False, [("$mod", "Super"), ("$alt", "Alt")]),
    'kitty': (os.path.join(os.getenv('HOME'), '.config/kitty/kitty.conf'), ['map', '# map'], False, [("kitty_mod", "ctrl+shift")]),
    'helix': (os.path.join(os.getenv('HOME'), '.config/helix/config.toml'), ['C-', '"C-'], True, []),
    'notificationcenter': (os.path.join(os.getenv('HOME'), '.config/swaync/shortcuts.txt'), ['*'], False, []),
}


def get_bindings(config, keywords, keep_keyword, mappings):
    if os.path.isfile(config):
        with open(config) as f:
            content = f.readlines()
        bindings = []
        for line in content:
            print(line)
            line = line.strip()
            for k in keywords:
                if line.startswith(k):
                    if not keep_keyword:
                        # remove the keyword
                        line = line[len(k):].strip()
                    for old, new in mappings:
                        line = line.replace(old, new)
                    bindings.append(line)
                    break
        return sorted(bindings)
    else:
        print('{} file not found'.format(config))
        exit(1)


class GUI:
    def __init__(self, mode):
        config = configs[mode][0]
        lines = get_bindings(config, configs[mode][1], configs[mode][2], configs[mode][3])

        # parsed entries for display and filtering
        self.entries = []
        for line in lines:
            parts = line.split()
            key = parts[0]
            command = ' '.join(parts[1:])
            self.entries.append((key, command))

        screen = Gdk.Screen.get_default()
        h = screen.get_height()
        window = Gtk.Window()
        window.set_default_size(h * 0.7, h * 0.95)
        window.set_title("Cheatsheet for {}".format(mode))
        window.connect_after('destroy', self.destroy)

        # layout: search entry above the scrolled text view
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)

        search = Gtk.Entry()
        search.set_placeholder_text('Type to filter (fuzzy)')
        search.connect('changed', self.on_search_changed)
        search.set_hexpand(True)
        search.grab_focus()

        preview = Gtk.ScrolledWindow()
        preview.set_propagate_natural_height(True)
        preview.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.ALWAYS)

        text_view = Gtk.TextView()
        text_view.set_top_margin(10)
        text_view.set_left_margin(10)
        text_view.set_bottom_margin(10)
        text_view.set_right_margin(10)
        text_view.set_editable(False)
        text_buffer = text_view.get_buffer()
        tag_bold = text_buffer.create_tag("bold", weight=Pango.Weight.BOLD)

        # save for other methods
        self.text_view = text_view
        self.text_buffer = text_buffer
        self.tag_bold = tag_bold

        # initial full population
        self._rebuild_buffer(self.entries)

        preview.add(text_view)
        vbox.pack_start(search, False, False, 0)
        vbox.pack_start(preview, True, True, 0)
        window.add(vbox)
        window.show_all()

    def destroy(window, self):
        Gtk.main_quit()

    def _rebuild_buffer(self, entries):
        # clear and (re)insert entries
        buf = self.text_buffer
        start, end = buf.get_start_iter(), buf.get_end_iter()
        buf.delete(start, end)

        for key, command in entries:
            position = buf.get_end_iter()
            buf.insert_with_tags(position, '[{} ] - '.format(key), self.tag_bold)
            position = buf.get_end_iter()
            buf.insert(position, ' {}\n'.format(command))

    def _fuzzy_match(self, query, text):
        # subsequence fuzzy match (simple, fast)
        if not query:
            return True
        q = query.lower()
        t = text.lower()
        qi = 0
        for ch in t:
            if ch == q[qi]:
                qi += 1
                if qi == len(q):
                    return True
        return False

    def on_search_changed(self, entry):
        q = entry.get_text()
        if not q:
            self._rebuild_buffer(self.entries)
            return

        filtered = []
        for key, command in self.entries:
            display = '[{} ] - {}'.format(key, command)
            if self._fuzzy_match(q, display):
                filtered.append((key, command))

        self._rebuild_buffer(filtered)


def main():
    if sys.argv[1] == 'list':
        for cfg in configs.keys():
            print(cfg)
        exit(0)
    # determine mode from command line argument
    if len(sys.argv) > 1 and sys.argv[1] in configs:
        mode = sys.argv[1]
    else:
        print("Usage: {} [list|sway|kitty|helix]".format(sys.argv[0]))
        exit(1)
    app = GUI(mode)
    Gtk.main()


if __name__ == "__main__":
    sys.exit(main())
